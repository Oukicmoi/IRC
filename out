
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/13 16:58:31 by gtraiman          #+#    #+#              #
#    Updated: 2025/05/14 20:15:57 by gtraiman         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


NAME        = ircserv

CXX         = c++
CXXFLAGS    = -std=c++98 -Wall -Wextra -Werror -g3
INCLUDE = include

SRCS        = src/main.cpp \
              src/Server.cpp \
              src/Channel.cpp \
              src/IRCMessage.cpp
            #   src/User.cpp \

OBJS        = $(SRCS:.cpp=.o)

all: $(NAME)

$(NAME): $(OBJS)
	$(CXX) $(CXXFLAGS) $(OBJS) -o $(NAME)

src/%.o: src/%.cpp
	$(CXX) $(CXXFLAGS) -I$(INCLUDE) -c $< -o $@

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Channel.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:26:03 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/13 16:26:04 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:21:41 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/13 16:54:54 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#ifndef CLIENT_HPP
#define CLIENT_HPP

#include "lib.hpp"

class Client
{
    protected:
        std::string     _nick;
        unsigned int    _id;
        static unsigned int _nextId;

    public:
        Client();
        Client(const std::string& nick);
        ~Client();

        void            setNick(const std::string& nick);
        std::string     getNick() const;

        void            setId(unsigned int id);
        unsigned int    getId() const;
};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   IRCMessage.hpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:26:09 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/13 16:26:11 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   RPL.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:51:32 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/13 16:51:33 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once
#include <iostream>

void	sendServerRpl(int const client_fd, std::string client_buffer);

# define user_id(nickname, username) (":" + nickname + "!" + username + "@localhost")

# define RPL_WELCOME(user_id, nickname) (":localhost 001 " + nickname + " :Welcome to the Internet Relay Network " + user_id + "\r\n")
# define RPL_YOURHOST(client, servername, version) (":localhost 002 " + client + " :Your host is " + servername + " (localhost), running version " + version + "\r\n")
# define RPL_CREATED(client, datetime) (":localhost 003 " + client + " :This server was created " + datetime + "\r\n")
# define RPL_MYINFO(client, servername, version, user_modes, chan_modes, chan_param_modes) (":localhost 004 " + client + " " + servername + " " + version + " " + user_modes + " " + chan_modes + " " + chan_param_modes + "\r\n")
//# define RPL_ISUPPORT(client, tokens) (":localhost 005 " + client + " " + tokens " :are supported by this server\r\n")

# define ERR_UNKNOWNCOMMAND(client, command) (":localhost 421 " + client + " " + command + " :Unknown command\r\n")
# define ERR_NOTREGISTERED(client) (":localhost 451 " + client + " :You have not registered\r\n")


// INVITE
# define ERR_NEEDMOREPARAMS(client, command) (":localhost 461 " + client + " " + command + " :Not enough parameters.\r\n")
# define ERR_NOSUCHCHANNEL(client, channel) (":localhost 403 " + client + " " + channel + " :No such channel\r\n")
# define ERR_NOSUCHNICK(client, target) ("localhost 401 " + client + " " + target + " :No such nick/channel\r\n")
# define ERR_ALREADYINVITED(client, target, channel) (":localhost 443 " + client + " " + target + " " + channel + " :is already invited\r\n")
# define ERR_INVITEYOURSELF(client) (":localhost 502 " + client + " :Cannot invite yourself\r\n")
# define ERR_USERONCHANNEL(client, nick, channel) (":localhost 443 " + client + " " + nick + " " + channel + " :Is already on channel\r\n")
# define RPL_INVITE(user_id, invited, channel) (user_id + " INVITE " + invited + " " + channel + "\r\n")
# define RPL_INVITING(client, target, channel) ("localhost 341 " + client + " inviting " + target + " " + channel + "\r\n")


// JOIN
# define RPL_JOIN(user_id, channel) (user_id + " JOIN :" +  channel + "\r\n")
//# define ERR_BANNEDFROMCHAN(client, channel) ("474 " + client + " #" + channel + " :Cannot join channel (+b)\r\n")
# define ERR_BADCHANNELKEY(client, channel) (":localhost 475 " + client + " " + channel + " :Cannot join channel (+k)\r\n")
# define ERR_ALREADYJOINED(client, channel) (":localhost 443 " + client + " " + channel + " :Is already on channel\r\n")
# define ERR_INVITEONLY(client, channel) (":localhost 473 " + client + " " + channel + " :Cannot join channel (+i)\r\n")


// KICK
# define ERR_USERNOTINCHANNEL(client, nickname, channel) ("441 " + client + " " + nickname + " " + channel + " :They aren't on that channel\r\n")
// # define ERR_CHANOPRIVSNEEDED(client, channel) ("482 " + client + " #" +  channel + " :You're not channel operator\r\n")
# define RPL_KICK(channel, kicked, reason) (":localhost KICK " + channel + " " + kicked + " " + reason + "\r\n\n")
# define ERR_CANNOTKICKSELF(client) ("502 " + client + " :Cannot kick yourself\r\n")


// KILL
/* # define ERR_NOPRIVILEGES(client) ("481 " + client + " :Permission Denied- You're not an IRC operator\r\n")
# define RPL_KILL(user_id, killed, comment) (user_id + " KILL " + killed + " " + comment + "\r\n") */

// MODE
/* user mode */
#define MODE_USERMSG(client, mode) (":" + client + " MODE " + client + " :" + mode + "\r\n")
#define ERR_UMODEUNKNOWNFLAG(client) (":localhost 501 " + client + " :Unknown MODE flag\r\n")
#define ERR_USERSDONTMATCH(client) (":localhost 502 " + client + " :Cant change mode for other users\r\n")
#define RPL_UMODEIS(client, mode) (":localhost 221 " + client + " " + mode + "\r\n")
#define ERR_CANNOTREMOVEOP(client, channel) (":localhost 461 " + client + " " + channel + " :Operator can't be removed\r\n")

/* channel mode */
#define MODE_CHANNELMSG(channel, mode) (":localhost MODE " + channel + " " + mode + "\r\n")
#define MODE_CHANNELMSGWITHPARAM(channel, mode, param) (":localhost MODE " + channel + " " + mode + " " + param + "\r\n")
#define RPL_CHANNELMODEIS(client, channel, mode) (":localhost 324 " + client + " " + channel + " " + mode + "\r\n")
#define RPL_CHANNELMODEISWITHKEY(client, channel, mode, password) (":localhost 324 " + client + " " + channel + " " + mode + " " + password + "\r\n")
#define ERR_CANNOTSENDTOCHAN(client, channel) ("localhost 404 " + client + " " + channel + " :Cannot send to channel\r\n")
#define ERR_CHANNELISFULL(client, channel) ("localhost 471 " + client + " " + channel + " :Cannot join channel (+l)\r\n")
#define ERR_CHANOPRIVSNEEDED(client, channel) (":localhost 482 " + client + " " + channel + " :You're not channel operator\r\n")
#define ERR_INVALIDMODEPARAM(client, channel, mode, password) (":localhost 696 " + client + " " + channel + " " + mode + " " + password + " : password must only contained alphabetic character\r\n")
// RPL_ERR a broadcoast quand user pas +v ou operator veut parler
      // dans notre cas c'était tiff (client) qui voulait send a message
      // :lair.nl.eu.dal.net 404 tiff #pop :Cannot send to channel
#define RPL_ADDVOICE(nickname, username, channel, mode, param) (":" + nickname + "!" + username + "@localhost MODE " + channel + " " + mode + " " + param + "\r\n")

/* // MOTD
#define ERR_NOSUCHSERVER(client, servername) (":localhost 402 " + client + " " + servername + " :No such server\r\n")
#define ERR_NOMOTD(client) (":localhost 422 " + client + " :MOTD File is missing\r\n")
#define RPL_MOTDSTART(client, servername) (":localhost 375 " + client + " :- " + servername + " Message of the day - \r\n")
#define RPL_MOTD(client, motd_line) (":localhost 372 " + client + " :" + motd_line + "\r\n")
#define RPL_ENDOFMOTD(client) (":localhost 376 " + client + " :End of /MOTD command.\r\n")


// NAMES
# define RPL_NAMREPLY(client, symbol, channel, list_of_nicks) (":localhost 353 " + client + " " + symbol + " " + channel + " :" + list_of_nicks + "\r\n")
# define RPL_ENDOFNAMES(client, channel) (":localhost 366 " + client + " " + channel + " :End of /NAMES list.\r\n") */

// NICK
# define ERR_NONICKNAMEGIVEN(client) (":localhost 431 " + client + " :There is no nickname.\r\n")
# define ERR_ERRONEUSNICKNAME(client, nickname) (":localhost 432 " + client + " " + nickname + " :Erroneus nickname\r\n")
# define ERR_NICKNAMEINUSE(client, nickname) (":localhost 433 " + client + " " + nickname + " :Nickname is already in use.\r\n")
# define RPL_NICK(oclient, uclient, client) (":" + oclient + "!" + uclient + "@localhost NICK " +  client + "\r\n")

// NOTICE
/* # define RPL_NOTICE(nick, username, target, message) (":" + nick + "!" + username + "@localhost NOTICE " + target + " " + message + "\r\n") */

// OPER
/* # define ERR_NOOPERHOST(client) ("491 " + client + " :No O-lines for your host\r\n")
# define RPL_YOUREOPER(client) ("381 " + client + " :You are now an IRC operator\r\n") */

// PART
# define RPL_PART(user_id, channel, reason) (std::string(user_id) + " PART " + channel + " " + (std::string(reason).empty() ? "." : std::string(reason)) + "\r\n")
# define ERR_NOSUCHCHANNEL(client, channel) (":localhost 403 " + client + " " + channel + " :No such channel\r\n")
# define ERR_NOTONCHANNEL(client, channel) (":localhost 442 " + client + " " + channel + " :You're not on that channel\r\n")


// PASS
# define ERR_PASSWDMISMATCH(client) (":localhost 464 " + client + " :Password incorrect.\r\n")

// PING
# define RPL_PONG(user_id, token) (user_id + " PONG " + token + "\r\n")

// QUIT
/* # define RPL_QUIT(user_id, reason) (user_id + " QUIT :Quit: " + reason + "\r\n")
# define RPL_ERROR(user_id, reason) (user_id + " ERROR :" + reason + "\r\n") */

// PRIVMSG
# define ERR_NOSUCHNICK(client, target) ("localhost 401 " + client + " " + target + " :No such nick/channel\r\n")
# define ERR_NORECIPIENT(client) (":localhost 411 " + client + " :No recipient given PRIVMSG\r\n")
# define ERR_NOTEXTTOSEND(client) (":localhost 412 " + client + " :No text to send\r\n")
# define RPL_PRIVMSG(nick, username, target, message) (":" + nick + "!" + username + "@localhost PRIVMSG " + target + " " + message + "\r\n")

// TOPIC
# define RPL_TOPIC(client, channel, topic) (":localhost 332 " + client + " " + channel + " " + topic + "\r\n")
# define RPL_NOTOPIC(client, channel) (":localhost 331 " + client + " " + channel + " :No topic is set\r\n")

// USER
# define ERR_ALREADYREGISTERED(client) (":localhost 462 " + client + " :You may not reregister.\r\n")/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 15:58:21 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/14 21:19:28 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

# ifndef SERVER_HPP
#define SERVER_HPP

# include "lib.hpp"
// # include "User.hpp"
# include <sys/epoll.h>
#include <tr1/unordered_map>
# include <sys/resource.h>

# define B "\x1B[1m"
# define U "\x1B[4m"
# define R "\033[0m"

# define RED "\033[0;31m"
# define GREEN "\033[1;32m"
# define YELLOW "\033[1;33m"
# define CYAN "\033[0;36m"
# define MAGENTA "\033[0;35m"

# define ALLOW_NOT_RECOMMENDED_PORT true
# define DEFAULT_PORT 6667
# define MAX_WAITING_ROOM SOMAXCONN

#define ERR_SYS(msg) std::cerr << RED << B << "error " << msg << ": " << R << std::strerror(errno) << std::endl

class Server
{
    private:
        std::string						_mdp;
        unsigned int					_port;
		struct sockaddr_in				_server_addr;
		int								_socket_fd;
		int								_epoll_fd;
		// std::tr1::unordered_map<int, User>	_users;

		void	init_socket_address(void);
		bool	set_non_blocking_socket(int socket_fd);
		bool	init_socket(void);
		bool	add_to_epoll(int socket_fd, uint32_t event_type);
		bool	init_epoll(void);
		void	addUsers(void);

    public:
        Server();
		Server(unsigned int port, const std::string& password);
        ~Server();

        void setmdp(const std::string& password);
        std::string getmdp() const;
        unsigned int getport() const;

	
		bool	init(void);
		void	up(void);
};


#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   all.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:24:19 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/14 20:12:27 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


# ifndef ALL_HPP
#define ALL_HPP

#include "Channel.hpp"
// #include "User.hpp"
#include "IRCMessage.hpp"
#include "RPL.hpp"
#include "Server.hpp"

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lib.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:22:52 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/14 20:43:18 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


# ifndef LIB_HPP
#define LIB_HPP


// C++ Standard Library
#include <iostream>     // cout, cerr
#include <string>       // std::string
#include <vector>       // std::vector
#include <map>          // std::map
#include <set>          // std::set
#include <sstream>      // std::istringstream, std::ostringstream
#include <algorithm>    // std::find, std::remove_if…
#include <cstring>      // std::memcpy, std::strlen
#include <cerrno>       // errno
#include <csignal>      // signal, sigaction
#include <cstdlib>      // std::exit, std::atoi

// POSIX / Sockets / I/O non-bloquante
#include <unistd.h>     // close, read, write, lseek
#include <fcntl.h>      // fcntl (O_NONBLOCK)
#include <sys/types.h>  // types divers
#include <sys/socket.h> // socket, bind, listen, accept, send, recv, setsockopt
#include <netinet/in.h> // sockaddr_in, htons, htonl, ntohs, ntohl
#include <arpa/inet.h>  // inet_addr, inet_ntoa
#include <netdb.h>      // getaddrinfo, freeaddrinfo, gethostbyname, getprotobyname
#include <poll.h>       // poll
#include <signal.h>     // signal, sigaction
#include <sys/stat.h>   // fstat (si utilisé)


#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Channel.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 15:54:36 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/13 15:54:37 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:55:10 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/13 16:55:26 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Client.hpp"

unsigned int Client::_nextId = 1;

Client::Client() : _nick(""), _id(_nextId++) {}

Client::Client(const std::string& nick) : _nick(nick), _id(_nextId++) {}

Client::~Client() {}

void Client::setNick(const std::string& nick)
{
    _nick = nick;
}

std::string Client::getNick() const
{
    return _nick;
}

void Client::setId(unsigned int id)
{
    _id = id;
}

unsigned int Client::getId() const
{
    return _id;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 16:12:54 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/14 21:21:38 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "all.hpp"

Server::Server() : _mdp(""), _port(DEFAULT_PORT) {}



Server::Server(unsigned int port, const std::string& password) : _mdp(password)
{
	// _users;
	_socket_fd = -1;
	_epoll_fd = -1;
	std::memset(&_server_addr, 0, sizeof(_server_addr)); // mise à 0 de tout l'espace de l'addresse serveur pour éviter des bugs futurs
    
	if (!ALLOW_NOT_RECOMMENDED_PORT && (port <= 1023))
		throw std::invalid_argument("Port integer is recommended to be between 1024 and 65535");
	if ((port > 65535))
		throw std::invalid_argument("Port integer should be inferior to 65535");
	_port = port;
}

Server::~Server()
{
	// _users.clear();
	if (_epoll_fd >= 0)
		close(_epoll_fd);
	if (_socket_fd)	
		close(_socket_fd);
}

// SETTERS

void Server::setmdp(const std::string& password) { _mdp = password; }

// GETTERS

std::string Server::getmdp() const { return (_mdp); }
unsigned int Server::getport() const { return (_port); }

///////////////////////////////////////////////////////////////


void	Server::init_socket_address(void)
{
	_server_addr.sin_family = AF_INET;
    _server_addr.sin_port = htons(_port); // network port -> big-endian donc conversion du port en big-endian
    _server_addr.sin_addr.s_addr = INADDR_ANY; // listen all IP adresses
}

bool	Server::set_non_blocking_socket(int socket_fd)
{
	int	flags = fcntl(socket_fd, F_GETFL, 0);  // Récupère les flags actuels
	if (flags == -1)
	{
		ERR_SYS("ftnl (get flags)");
	    return (false);
	}
	if (fcntl(socket_fd, F_SETFL, flags | O_NONBLOCK) < 0)
	{
		
		ERR_SYS("ftnl (set flags)");
        return (false);
	}
	std::cout << B << "\tfd=" << socket_fd << R << " put in " << B << "mode non-blocking" << R << std::endl;
	return (true);
}

bool	Server::init_socket(void)
{
	// 1. Création du socket TCP
    _socket_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // AF_INET = famille de protocle IPv4, SOCK_STREAM = Socket TCP, IPPROTO_TCP = protocole TCP
    if (_socket_fd < 0)
	{
		ERR_SYS("socket");
        return (false);
    }
	std::cout << B << CYAN << "Server Socket" << R << " (TCP/IPv4) created on " << B << "fd " << _socket_fd << R << std::endl;
	
	// if (setsockopt(_server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &optval, sizeof(optval)) < 0){
	// 	std::cout << "Error:\tCreation socket failed." << std::endl;
	// 	return ; // TODO gérer ce caca
	// }

	if (!set_non_blocking_socket(_socket_fd))
		return (false);

    // 2. Configuration de l'adresse du serveur
    init_socket_address();

    if (bind(_socket_fd, (struct sockaddr *)&_server_addr, sizeof(_server_addr)) < 0)
	{
		ERR_SYS("bind");
		return (false);
    }
	std::cout << B << CYAN << "Server Socket" << R << " bind to " << B << "port " << _port << R << std::endl;

    if (listen(_socket_fd, MAX_WAITING_ROOM) < 0)
	{
		ERR_SYS("listen");
		return 1;
    }
    std::cout << std::endl << "Serveur en écoute sur le port " << _port << "..." << std::endl << std::endl;
    return (true);
}

bool	Server::add_to_epoll(int socket_fd, uint32_t event_type)
{
	struct epoll_event	event;
    memset(&event, 0, sizeof(event));
    event.events = event_type;
    event.data.fd = socket_fd;
    if (epoll_ctl(_epoll_fd, EPOLL_CTL_ADD, socket_fd, &event) == -1)
	{
		ERR_SYS("epoll_ctl");
		return (false);
    }
	return (true);
}

bool	Server::init_epoll(void)
{
	_epoll_fd = epoll_create1(0);
    if (_epoll_fd == -1)
	{
		ERR_SYS("epoll_create1");
        return (false);
    }
	return (add_to_epoll(_socket_fd, EPOLLIN | EPOLLET)); // add EPOLLEXCLUSIVE pour multiprocess/threading -> plusieurs process/thread epoll_add une même socket, et leurs epoll_wait respectifs se fight pour gérer un event qui arrive, ce flag assure qu'il n'y en a qu'un qui la gérera évitant des problèmes liés au racing par exemple
}

bool	Server::init(void) // TODO mettre le init dans le constructor
{
    if (!init_socket())
		return (false);
	return (init_epoll());
}	

void	Server::addUsers(void)	
{
	socklen_t	addrlen = sizeof(_server_addr);
    int client_fd = accept(_socket_fd, (struct sockaddr *)&_server_addr, &addrlen);
	while (client_fd >= 0)
	{
		std::cout << "\tnew " << B << "connection " << GREEN << "accepted" << R << " on " << B << "fd " << client_fd << R << std::endl;
		client_fd = accept(_socket_fd, (struct sockaddr *)&_server_addr, &addrlen);
	}
    if (client_fd == -1)
	{
		if ((errno != EAGAIN) && (errno != EWOULDBLOCK))
		{
			std::cout << "\t";
			ERR_SYS("accept");
		}
    }
}

extern volatile bool g_running;

void	Server::up()
{
	struct epoll_event events[MAX_WAITING_ROOM];
	while (g_running)
	{
		int events_count = epoll_wait(_epoll_fd, events, MAX_WAITING_ROOM, -1);
		if (events_count == -1)
		{
			// ERR_SYS("epoll_wait");
			break ;
		}
		int event_index = 0;
		while (event_index < events_count)
		{
			std::cout << "New event: " << B "fd=" << events[event_index].data.fd << R << ", " << B << "type=" << events[event_index].events << R << std::endl;
			if (events[event_index].events && (events[event_index].events == EPOLLIN))
				addUsers();
			event_index ++;
		}
		if (events_count)
			std::cout << std::endl;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: gtraiman <gtraiman@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 15:57:35 by gtraiman          #+#    #+#             */
/*   Updated: 2025/05/14 21:20:40 by gtraiman         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "all.hpp"

volatile bool g_running = true;

void signal_handler(int signal)
{
    if (signal == SIGINT || signal == SIGTERM || signal == SIGTSTP)
    {
        std::cout << "\nSIGNAL D'ARRET DU SERVEUR RECU, GOODBYE\n";
        g_running = false;
    }
}

void	show_limits(void)
{
	std::cout << "Socket Maximum Connections: " << B << MAX_WAITING_ROOM << R << "/" << SOMAXCONN << std::endl;
	struct rlimit rlim;
	// Récupère la limite de descripteurs de fichiers (RLIMIT_NOFILE)
	std::cout << "Opened Fd limits" << std::endl;
	if (getrlimit(RLIMIT_NOFILE, &rlim) == 0)
	{
		std::cout << "\t- Limite actuelle (soft): " << B << (long long)rlim.rlim_cur << R << std::endl;
		std::cout << "\t- Limite maximale (hard): " << (long long)rlim.rlim_max << std::endl;
	}
	else
		std::cout << "getrlimit failed: " << strerror(errno) << std::endl;
	std::cout << std::endl;
}

int main(int ac, char **av)
{
    if (ac != 3)
    {
        std::cerr << "Usage: " << av[0] << " <port> <password>\n";
        return 1;
    }

	struct sigaction sa;
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGTSTP, &sa, NULL);
    try
    {
        char **end = NULL;
        Server server(std::strtod(av[1],end), av[2]);

		show_limits();
	
		if (!server.init())
			return (1);
		server.up();
    }
    catch(const std::exception& e)
    {
        std::cerr << e.what() <<std::endl;    
    }
    return(0);
}#! /bin/bash

for (( c=1; c<=$2; c++ ))
do  
  nc localhost $1 &
done